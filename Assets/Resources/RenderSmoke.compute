#pragma kernel CS_GenerateNoise
#pragma kernel CS_DebugNoise
#pragma kernel CS_RayMarchSmoke

#include "UnityCG.cginc"
#include "UnityStandardBRDF.cginc"
#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise3D.hlsl"

#define STEPS 256
#define MIN_HIT_DISTANCE 0.001
#define MAX_DISTANCE 1000

RWTexture3D<half> _RWNoiseTex;
Texture3D<half> _NoiseTex;
SamplerState linear_repeat_sampler;

RWTexture2D<float4> _SmokeTex;
RWTexture2D<float> _SmokeDepthTex;
RWTexture2D<half> _SmokeMaskTex;

float3 _CameraWorldPos;
float3 _SunDirection;
float4x4 _CameraToWorld;
float4x4 _CameraInvProjection;
float4x4 _CameraViewProjection;
float _BufferWidth;
float _BufferHeight;

uint _Shape;
float _Radius;
float4 _CubeParams;

int _StepCount;
float _StepSize;

int _Octaves;
float _Persistance, _Amplitude, _Warp, _Add;
int _CellSize, _Roughness, _Period, _Frequency;

[numthreads(8,8,8)]
void CS_GenerateNoise(uint3 id : SV_DISPATCHTHREADID) {
    //Convert to UV
    float3 pos = float3(id.xyz) / 128.0f;
    pos *= _CellSize;

    float n = 0.0f;

    float G = exp2(-_Persistance);
    float f = rcp(exp2(_Frequency));
    float a = _Amplitude;

    for (int i = 0; i < _Octaves; ++i) {
        n += a * PeriodicNoise(pos.xyz * f + i * _Warp, _Period * f);
        f *= _Roughness;
        a *= G;
    }

    _RWNoiseTex[id.xyz] = saturate(n + _Add);
}

uint _DebugNoiseSlice;
uint _DebugAxis;
uint _DebugTiledNoise;

float RaymarchNoisePlane(float3 rayOrigin, float3 rayDir) {
    float distance = 0.0f;

    float3 n = 0;
    if (_DebugAxis == 0) n.x = 1;
    if (_DebugAxis == 1) n.y = 1;
    if (_DebugAxis == 2) n.z = 1;

    for (int i = 0; i < STEPS && distance < MAX_DISTANCE; ++i) {
        float3 pos = rayOrigin + distance * rayDir;     
        float distanceToObject = max(dot(pos, -n), dot(pos, n));
        distance += distanceToObject;

        if (distanceToObject < MIN_HIT_DISTANCE) return distance;
    }

    return MAX_DISTANCE;
}

[numthreads(8,8,1)]
void CS_DebugNoise(uint3 id : SV_DISPATCHTHREADID) {
    float3 origin = _CameraWorldPos;

    float2 uv = (id.xy / float2(_BufferWidth, _BufferHeight)) * 2 - 1;
    float3 direction = mul(_CameraInvProjection, float4(uv, 1.0f, 1.0f)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    float d = RaymarchNoisePlane(origin, direction);

    float4 col = 0.0f;
    if (d < MAX_DISTANCE) {
        float3 pos = origin + direction * d;

        if ((all(pos > -1) && all(pos < 1)) || _DebugTiledNoise) {
            pos /= _CellSize;
            if (_DebugAxis == 0) pos.x = (_DebugNoiseSlice - 1) / 128.0f;
            if (_DebugAxis == 1) pos.y = (_DebugNoiseSlice - 1) / 128.0f;
            if (_DebugAxis == 2) pos.z = (_DebugNoiseSlice - 1) / 128.0f;

            col.rgb = _NoiseTex.SampleLevel(linear_repeat_sampler, pos, 0).r;
        }
    }

    _SmokeTex[id.xy] = col;
}

float GetSphereDist(float3 pos) {
    return length(pos - 0) - _Radius;
}

float GetCubeDist(float3 pos) {
    float3 q = abs(pos - _CubeParams.xyz) - _CubeParams.w;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float GetDist(float3 pos) {
    if (_Shape == 0) return GetSphereDist(pos);
    if (_Shape == 1) return GetCubeDist(pos);

    return MAX_DISTANCE;
}


float4 RaymarchSmokeMesh(float3 rayOrigin, float3 rayDir) {
    float distance = 0.0f;

    for (int i = 0; i < STEPS && distance < MAX_DISTANCE; ++i) {
        float3 pos = rayOrigin + distance * rayDir;

        float distanceToObject = GetDist(pos);
        distance += distanceToObject;

        if (distanceToObject < MIN_HIT_DISTANCE)
            return float4(pos, distance);
    }

    return MAX_DISTANCE;
}

float3 CalcNormal(float3 p) {
    float2 e = float2(0.001, 0);
    float3 n = GetDist(p) - float3(
        GetDist(p - e.xyy), 
        GetDist(p - e.yxy), 
        GetDist(p - e.yyx)
    );

    return normalize(n);
}

[numthreads(8,8,1)]
void CS_RayMarchSmoke (uint3 id : SV_DispatchThreadID) {
    float3 origin = _CameraWorldPos;

    float2 uv = (id.xy / float2(_BufferWidth, _BufferHeight)) * 2 - 1;
    float3 direction = mul(_CameraInvProjection, float4(uv, 1.0f, 1.0f)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    float4 hitPos = RaymarchSmokeMesh(origin, direction);

    float4 col = 0.0f;
    float accumulatedNoise = 0.0f;
    if (hitPos.w < MAX_DISTANCE) {
        float3 n = -CalcNormal(hitPos.xyz);

        float ndotl = DotClamped(_SunDirection, n) * 0.5f + 0.5f;
        ndotl *= ndotl;

        col.rgb = 1;

        int maxSteps = _StepCount;
        float3 curPos = hitPos.xyz;
        float stepSize = _StepSize;

        for (int i = 0; i < maxSteps; ++i) {
            float n = saturate(_NoiseTex.SampleLevel(linear_repeat_sampler, curPos / 8.0f, 0).r);
            accumulatedNoise += n * stepSize;
            curPos += direction * stepSize;
            if (GetDist(curPos) > MIN_HIT_DISTANCE) break;
        }
    }

    //_SmokeTex[id.xy] = float4(uv, 0, 0);
    _SmokeTex[id.xy] = col;
    _SmokeMaskTex[id.xy] = saturate(accumulatedNoise);

    float4 clipPos = mul(_CameraViewProjection, float4(hitPos.xyz, 1.0f));

    _SmokeDepthTex[id.xy] = clipPos.z / clipPos.w;
}
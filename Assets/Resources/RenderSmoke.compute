#pragma kernel CS_GenerateNoise
#pragma kernel CS_DebugNoise
#pragma kernel CS_RayMarchSmoke

#include "UnityCG.cginc"
#include "UnityStandardBRDF.cginc"
#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise3D.hlsl"

#define STEPS 256
#define MIN_HIT_DISTANCE 0.001
#define MAX_DISTANCE 1000

RWTexture3D<half> _RWNoiseTex;
Texture3D<half> _NoiseTex;
SamplerState linear_repeat_sampler;

RWTexture2D<float4> _SmokeTex;
RWTexture2D<float> _SmokeDepthTex;
RWTexture2D<half> _SmokeMaskTex;

Texture2D<half> _DepthTex;

float3 _CameraWorldPos;
float3 _SunDirection;
float4x4 _CameraToWorld;
float4x4 _CameraInvProjection;
float4x4 _CameraViewProjection;
float4x4 _CameraInvViewProjection;
float _BufferWidth;
float _BufferHeight;
float _FrameTime;

uint _Shape;
float _Radius;
float4 _CubeParams;

int _StepCount;
float _StepSize;
float _SmokeSize;
float3 _SmokeColor;

float3 _AnimationDirection;
float _AnimationSpeed;

int _Octaves;
float _Persistance, _Amplitude, _Warp, _Add;
int _CellSize, _Roughness, _Period, _Frequency;

[numthreads(8,8,8)]
void CS_GenerateNoise(uint3 id : SV_DISPATCHTHREADID) {
    //Convert to UV
    float3 pos = float3(id.xyz) / 128.0f;
    pos *= _CellSize;

    float n = 0.0f;

    float G = exp2(-_Persistance);
    float f = rcp(exp2(_Frequency));
    float a = _Amplitude;

    for (int i = 0; i < _Octaves; ++i) {
        n += a * PeriodicNoise(pos.xyz * f + i * _Warp, _Period * f);
        f *= _Roughness;
        a *= G;
    }

    _RWNoiseTex[id.xyz] = saturate(n + _Add);
}

uint _DebugNoiseSlice;
uint _DebugAxis;
uint _DebugTiledNoise;

float RaymarchNoisePlane(float3 rayOrigin, float3 rayDir) {
    float distance = 0.0f;

    float3 n = 0;
    if (_DebugAxis == 0) n.x = 1;
    if (_DebugAxis == 1) n.y = 1;
    if (_DebugAxis == 2) n.z = 1;

    for (int i = 0; i < STEPS && distance < MAX_DISTANCE; ++i) {
        float3 pos = rayOrigin + distance * rayDir;     
        float distanceToObject = max(dot(pos, -n), dot(pos, n));
        distance += distanceToObject;

        if (distanceToObject < MIN_HIT_DISTANCE) return distance;
    }

    return MAX_DISTANCE;
}

[numthreads(8,8,1)]
void CS_DebugNoise(uint3 id : SV_DISPATCHTHREADID) {
    float3 origin = _CameraWorldPos;

    float2 uv = (id.xy / float2(_BufferWidth, _BufferHeight)) * 2 - 1;
    float3 direction = mul(_CameraInvProjection, float4(uv, 1.0f, 1.0f)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    float d = RaymarchNoisePlane(origin, direction);

    float4 col = 0.0f;
    if (d < MAX_DISTANCE) {
        float3 pos = origin + direction * d;

        if ((all(pos > -1) && all(pos < 1)) || _DebugTiledNoise) {
            pos /= _CellSize;
            if (_DebugAxis == 0) pos.x = (_DebugNoiseSlice - 1) / 128.0f;
            if (_DebugAxis == 1) pos.y = (_DebugNoiseSlice - 1) / 128.0f;
            if (_DebugAxis == 2) pos.z = (_DebugNoiseSlice - 1) / 128.0f;

            col.rgb = _NoiseTex.SampleLevel(linear_repeat_sampler, pos, 0).r;
        }
    }

    _SmokeTex[id.xy] = col;
}

float hash(uint n) {
    // integer hash copied from Hugo Elias
	n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x1376312589U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}

bool solveQuadratic(float a, float b, float c, inout float t0, inout float t1) {
    float discr = b * b - 4.0f * a * c;
    if (discr < 0) return false;
    else if (discr == 0) t0 = t1 = -0.5f * b / a;
    else {
        float q = (b > 0) ? -0.5f * (b + sqrt(discr)) : -0.5f * (b - sqrt(discr));

        t0 = q / a;
        t1 = c / q;
    }

    if (t0 > t1) {
        float temp = t0;
        t0 = t1;
        t1 = temp;
    }

    if (t0 < 0) return false;

    return true;
}

float3 GetSphereHit(float3 rayOrigin, float3 rayDir) {
    float3 center = _CubeParams.xyz;
    float3 L = rayOrigin - center;

    float a = 1;
    float b = 2 * dot(L, rayDir);
    float c = dot(L, L) - _Radius * _Radius;

    float t0, t1;
    if (!solveQuadratic(a, b, c, t0, t1)) return 0;

    return float3(t0, t1, 1);
}

float GetCubeDist(float3 pos) {
    float3 q = abs(pos - _CubeParams.xyz) - _CubeParams.w;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}


float3 RaycastSmokeMesh(float3 rayOrigin, float3 rayDir) {
    return GetSphereHit(rayOrigin, rayDir);
}


float3 ComputeWorldSpacePosition(float2 positionNDC, float deviceDepth) {
    float4 positionCS = float4(positionNDC * 2.0 - 1.0, deviceDepth, 1.0);
    float4 hpositionWS = mul(_CameraInvViewProjection, positionCS);
    return hpositionWS.xyz / hpositionWS.w;
}

[numthreads(8,8,1)]
void CS_RayMarchSmoke (uint3 id : SV_DispatchThreadID) {
    float2 uv = id.xy / float2(_BufferWidth, _BufferHeight);
    uint seed = id.x + _BufferWidth * id.y + _BufferWidth * _BufferHeight;
    float sceneDepth = _DepthTex.SampleLevel(linear_repeat_sampler, uv, 0).r;

    float3 sceneWorldPos = ComputeWorldSpacePosition(uv, sceneDepth);

    // Create camera ray
    float3 origin = _CameraWorldPos;
    float3 rayDir = mul(_CameraInvProjection, float4(uv * 2 - 1, 0.0f, 1.0f)).xyz;
    rayDir = mul(_CameraToWorld, float4(rayDir, 0.0f)).xyz;
    rayDir = normalize(rayDir);

    // Intersect with smoke mesh
    float3 hit = RaycastSmokeMesh(origin, rayDir);
    float3 hitPos = origin + hit.x * rayDir;

    float4 col = 0.0f;
    float alpha = 0.0f;

    // Solve for t in: P = O + tD
    float sceneIntersectDistance = -((origin - sceneWorldPos) / rayDir).x;
    if (hit.z && (hit.x < sceneIntersectDistance)) {
        float3 p1 = origin + rayDir * hit.x;
        float3 p2 = origin + rayDir * hit.y;

        float distance = 0;
        float density = 0;
        /*
        for (int i = 0; i < _StepCount; ++i) {
            float3 curPos = hitPos.xyz + distance * rayDir;

            float3 uvw = curPos / _SmokeSize;
            uvw += _AnimationDirection * _FrameTime * _AnimationSpeed;

            float n = saturate(_NoiseTex.SampleLevel(linear_repeat_sampler, uvw, 0).r);
            density += n * _StepSize;
            distance += _StepSize;
        }
        */
        distance = min(length(p1 - sceneWorldPos), length(p1 - p2));
        alpha = 1 - saturate(exp(-distance * 0.5f));
    }

    //_SmokeTex[id.xy] = (smokeIntersectDistance < sceneIntersectDistance);
    _SmokeTex[id.xy] = float4(_SmokeColor, 1.0f);
    _SmokeMaskTex[id.xy] = alpha;

    // Calculate clip depth
    float4 clipPos = mul(_CameraViewProjection, float4(hitPos.xyz, 1.0f));
    _SmokeDepthTex[id.xy] = clipPos.z / clipPos.w;
}